<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Nim教程 (II)</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield and narimiran
*/

html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

body {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 1.125em;
  line-height: 1.5;
  color: #222;
  background-color: #FCFCFC; }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 1050px;
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box;
  margin-left: 1%;
}

.column:first-child,
.columns:first-child {
  margin-left: 0; }

.three.columns {
  width: 19%; }

.nine.columns {
  width: 80.0%; }

.twelve.columns {
  width: 100%;
  margin-left: 0; }

@media screen and (max-width: 860px) {
  .three.columns {
    display: none;
  }
  .nine.columns {
    width: 98.0%;
  }
  body {
    font-size: 1em;
    line-height: 1.35;
  }
}

cite {
  font-style: italic !important; }


/* Nim search input */
div#searchInputDiv {
  margin-bottom: 1em;
}
input#searchInput {
  width: 80%;
}

/*
 * Some custom formatting for input forms.
 * This also fixes input form colors on Firefox with a dark system theme on Linux.
 */
input {
  -moz-appearance: none;
  color: #333;
  background-color: #f8f8f8;
  border: 1px solid #aaa;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-size: 0.9em;
  padding: 6px;
}
input:focus {
  border: 1px solid #1fa0eb;
  box-shadow: 0 0 2px #1fa0eb;
}

/* Docgen styles */
/* Links */
a {
  color: #07b;
  text-decoration: none;
}

a span.Identifier {
  text-decoration: underline;
  text-decoration-color: #aab;
}

a.reference-toplevel {
  font-weight: bold;
}

a.toc-backref {
  text-decoration: none;
  color: #222; }

a.link-seesrc {
  color: #607c9f;
  font-size: 0.9em;
  font-style: italic; }

a:hover,
a:focus {
  color: #607c9f;
  text-decoration: underline; }

a:hover span.Identifier {
  color: #607c9f;
}


sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; }
}


p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

small {
  font-size: 85%; }

strong {
  font-weight: 600;
  font-size: 0.95em;
  color: #3c3c3c;
}

em {
  font-style: italic; }

h1 {
  font-size: 1.8em;
  font-weight: 400;
  padding-bottom: .25em;
  border-bottom: 1px solid #aaa;
  margin-top: 2.5em;
  margin-bottom: 1em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.5em;
  text-align: center;
  font-weight: 900;
  margin-top: 0.75em;
  margin-bottom: 0em;
}

h2 {
  font-size: 1.3em;
  margin-top: 2em; }

h2.subtitle {
  text-align: center; }

h3 {
  font-size: 1.125em;
  font-style: italic;
  margin-top: 1.5em; }

h4 {
  font-size: 1.125em;
  margin-top: 1em; }

h5 {
  font-size: 1.125em;
  margin-top: 0.75em; }

h6 {
  font-size: 1.1em; }


ul,
ol {
  padding: 0;
  margin-top: 0.5em;
  margin-left: 0.75em; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0;
  margin-left: 1.25em; }

li {
    list-style-type: circle;
}

ul.simple-boot li {
    list-style-type: none;
    margin-left: 0em;
    margin-bottom: 0.5em;
}

ol.simple > li, ul.simple > li {
  margin-bottom: 0.25em;
  margin-left: 0.4em }

ul.simple.simple-toc > li {
    margin-top: 1em;
}

ul.simple-toc {
  list-style: none;
  font-size: 0.9em;
  margin-left: -0.3em;
  margin-top: 1em; }

ul.simple-toc > li {
    list-style-type: none;
}

ul.simple-toc-section {
  list-style-type: circle;
  margin-left: 1em;
  color: #6c9aae; }


ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

ul.auto-toc {
  list-style-type: none; }


dl {
  margin-bottom: 1.5em; }

dt {
  margin-bottom: -0.5em;
  margin-left: 0.0em; }

dd {
  margin-left: 2.0em;
  margin-bottom: 3.0em;
  margin-top: 0.5em; }


hr {
  margin: 2em 0;
  border: 0;
  border-top: 1px solid #aaa; }

blockquote {
  font-size: 0.9em;
  font-style: italic;
  padding-left: 0.5em;
  margin-left: 0;
  border-left: 5px solid #bbc;
}

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 500;
  font-size: 0.85em;
  background-color: #f0f3ff;
  padding-left: 3px;
  padding-right: 3px;
  border-radius: 4px;
}

pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  color: #222;
  font-weight: 500;
  display: inline-block;
  box-sizing: border-box;
  min-width: 100%;
  padding: 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-size: 0.85em;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: ghostwhite;
  border: 1px solid #dde;
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }


/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: ghostwhite;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }


table {
  max-width: 100%;
  background-color: transparent;
  margin-top: 0.5em;
  margin-bottom: 1.5em;
  border-collapse: collapse;
  border-color: #ccc;
  border-spacing: 0;
  font-size: 0.9em;
}

table th, table td {
  padding: 0px 0.5em 0px;
}

table th {
  background-color: #e8e8e8;
  font-weight: bold; }

table th.docinfo-name {
    background-color: transparent;
}

table tr:hover {
  background-color: ghostwhite; }


/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }


div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  text-align: center;
  color: #666;
  font-size: smaller; }

div.footer {
    padding-top: 5em;
}

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.topic {
  margin: 2em; }

div.search_results {
  background-color: antiquewhite;
  margin: 3em;
  padding: 1em;
  border: 1px solid #4d4d4d;
}

div#global-links ul {
  margin-left: 0;
  list-style-type: none;
}

div#global-links > simple-boot {
    margin-left: 3em;
}

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-style: oblique; }

span.classifier-delimiter {
  font-weight: bold; }

span.option {
  white-space: nowrap; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #222; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Keyword ~ span.Identifier, dt pre > span.Identifier ~ span.Identifier,
dt pre > span.Operator ~ span.Identifier, dt pre > span.Other ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 16px;
  width: 16px;
  background-position: 0 0;
  background-size: 16px 16px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }

span.pragmadots {
  /* Position: relative frees us up to make the dots
  look really nice without fucking up the layout and
  causing bulging in the parent container */
  position: relative;
  /* 1px down looks slightly nicer */
  top: 1px;
  padding: 2px;
  background-color: #e8e8e8;
  border-radius: 4px;
  margin: 0 2px;
  cursor: pointer;
  font-size: 0.8em;
}

span.pragmadots:hover {
  background-color: #DBDBDB;
}
span.pragmawrap {
  display: none;
}

span.attachedType {
  display: none;
  visibility: hidden;
}
</style>

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim教程 (II)</h1>
    <div class="row">
  <div class="three columns">
  <div id="global-links">
    <ul class="simple-boot">
      <li>
        <a href="manual.html">Manual</a>
      </li>
      <li>
        <a href="lib.html">Standard library</a>
      </li>
      <li>
        <a href="theindex.html">Index</a>
      </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="引言_toc" href="#引言">引言</a></li>
<li><a class="reference" id="编译指示（pragmas）_toc" href="#编译指示（pragmas）">编译指示（Pragmas）</a></li>
<li><a class="reference" id="面向对象编程_toc" href="#面向对象编程">面向对象编程</a></li>
<ul class="simple"><li><a class="reference" id="面向对象编程-继承_toc" href="#面向对象编程-继承">继承</a></li>
<li><a class="reference" id="面向对象编程-相互递归类型_toc" href="#面向对象编程-相互递归类型">相互递归类型</a></li>
<li><a class="reference" id="面向对象编程-类型转换_toc" href="#面向对象编程-类型转换">类型转换</a></li>
<li><a class="reference" id="面向对象编程-对象变体_toc" href="#面向对象编程-对象变体">对象变体</a></li>
<li><a class="reference" id="面向对象编程-方法调用语法_toc" href="#面向对象编程-方法调用语法">方法调用语法</a></li>
<li><a class="reference" id="面向对象编程-属性_toc" href="#面向对象编程-属性">属性</a></li>
<li><a class="reference" id="面向对象编程-动态分发_toc" href="#面向对象编程-动态分发">动态分发</a></li>
</ul><li><a class="reference" id="异常_toc" href="#异常">异常</a></li>
<ul class="simple"><li><a class="reference" id="异常-raise语句_toc" href="#异常-raise语句">Raise语句</a></li>
<li><a class="reference" id="异常-try语句_toc" href="#异常-try语句">Try语句</a></li>
<li><a class="reference" id="异常-引发异常的procs注释_toc" href="#异常-引发异常的procs注释">引发异常的procs注释</a></li>
</ul><li><a class="reference" id="泛型_toc" href="#泛型">泛型</a></li>
<li><a class="reference" id="模板_toc" href="#模板">模板</a></li>
<ul class="simple"><li><a class="reference" id="模板-示例colon-提升过程_toc" href="#模板-示例colon-提升过程">示例: 提升过程</a></li>
</ul><li><a class="reference" id="编译成javascript_toc" href="#编译成javascript">编译成Javascript</a></li>
<li><a class="reference" id="part-3_toc" href="#part-3">Part 3</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td> 0.20.3</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="引言" href="#引言">引言</a></h1><blockquote><p>&quot;重复使得荒谬合理。&quot; -- Norman Wildberger</p></blockquote>
<p>本文档是 <em>Nim</em> 编程语言的高级构造部分。 <strong>注意本文档有些过时</strong> 因为 <a class="reference external" href="manual.html">manual</a>  <strong>包含更多高级语言特性的样例</strong> 。</p>

<h1><a class="toc-backref" id="编译指示（pragmas）" href="#编译指示（pragmas）">编译指示（Pragmas）</a></h1><p>编译指示是Nim中不用引用大量新关键字，给编译器附加信息、命令的方法。编译指示用特殊的 <tt class="docutils literal"><span class="pre">{.</span></tt> 和 <tt class="docutils literal"><span class="pre">.}</span></tt> 花括号括起来。本教程没有讲pragmas。 可用编译指示的描述见 <a class="reference external" href="manual.html#pragmas">manual</a> 或 <a class="reference external" href="nimc.html#additional-features">user guide</a> .</p>

<h1><a class="toc-backref" id="面向对象编程" href="#面向对象编程">面向对象编程</a></h1><p>虽然Nim对面向对象编程（OOP）的支持很简单，但可以使用强大的OOP技术。OOP看作 <em>一种</em> 程序设计方式，不是 <em>唯一</em> 方式。通常过程的解决方法有更简单和高效的代码。 特别是，更喜欢组合而不是继承通常是更好的设计。</p>

<h2><a class="toc-backref" id="面向对象编程-继承" href="#面向对象编程-继承">继承</a></h2><p>继承在Nim中是完全可选的。对象需要用运行时类型信息使用继承 要使用运行时类型信息启用继承，对象需要从 <tt class="docutils literal"><span class="pre">RootObj</span></tt> 继承。 这可以直接完成，也可以通过从继承自 <tt class="docutils literal"><span class="pre">RootObj</span></tt>  的对象继承来间接完成。 通常，具有继承的类型也被标记为“ref”类型，即使这不是严格执行的。要在运行时检查某个对象是否属于某种类型，可以使用 <tt class="docutils literal"><span class="pre">of</span></tt> 运算符。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>  <span class="Comment"># *表示 `name`可以从其它模块访问</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>       <span class="Comment"># 没有*表示字段对其它模块隐藏</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># Student从Person继承</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                      <span class="Comment"># 有一个id字段</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># is true</span>
<span class="Comment"># object construction:</span>
<span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">student</span><span class="Punctuation">[</span><span class="Punctuation">]</span></pre><p>继承是使用 <tt class="docutils literal"><span class="pre">object of</span></tt> 语法完成的。目前不支持多重继承。如果一个对象类型没有合适的祖先， <tt class="docutils literal"><span class="pre">RootObj</span></tt> 可以用作它的祖先，但这只是一个约定。 没有祖先的对象隐含地是“final”。你可以使用 <tt class="docutils literal"><span class="pre">inheritable</span></tt> pragma来引入除 <tt class="docutils literal"><span class="pre">system.RootObj</span></tt> 之外的新对象根。 （例如，这在GTK包装器中使用。）</p>
<p>只要使用继承，就应该使用Ref对象。它不是必须的，但是对于非ref对象赋值，例如 <tt class="docutils literal"><span class="pre">let person：Person = Student（id：123）</span></tt> 将截断子类字段。</p>
<p><strong>注意</strong> ：对于简单的代码重用，组合（*has-a* 关系）通常优于继承（*is-a* 关系）。由于对象是Nim中的值类型，因此组合与继承一样有效。</p>

<h2><a class="toc-backref" id="面向对象编程-相互递归类型" href="#面向对象编程-相互递归类型">相互递归类型</a></h2><p>对象，元组和引用可以模拟相互依赖的非常复杂的数据结构; 它们是 <em>相互递归的</em> 。在Nim中，这些类型只能在单个类型部分中声明。（任何其他东西都需要任意符号查询，这会减慢编译速度。）</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>  <span class="Comment"># 对具有以下字段的对象的引用：</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># 左右子树</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># 叶节点包含Sym的引用</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># 符号</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># 符号名</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 符号声明的行</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>       <span class="Comment"># 符号的抽象语法树</span></pre>
<h2><a class="toc-backref" id="面向对象编程-类型转换" href="#面向对象编程-类型转换">类型转换</a></h2><p>Nim区分 <span id="type-casts_1">type casts</span> 和 <span id="type-conversions_1">type conversions</span> 。使用 <tt class="docutils literal"><span class="pre">cast</span></tt> 运算符完成转换，并强制编译器将位模式解释为另一种类型。</p>
<p>类型转换是将类型转换为另一种类型的更友好的方式：它们保留抽象 <em>值</em> ，不一定是 <em>位模式</em> 。如果无法进行类型转换，则编译器会引发异常。</p>
<p>类型转换语法 <tt class="docutils literal"><span class="pre">destination_type(expression_to_convert)</span></tt> (像平时的调用):</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">getID</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Person</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">id</span></pre><p>如果 <tt class="docutils literal"><span class="pre">x</span></tt> 不是 <tt class="docutils literal"><span class="pre">Student</span></tt> ，则引发 <tt class="docutils literal"><span class="pre">InvalidObjectConversionError</span></tt> 异常。</p>

<h2><a class="toc-backref" id="面向对象编程-对象变体" href="#面向对象编程-对象变体">对象变体</a></h2><p>在需要简单变体类型的某些情况下，对象层次结构通常是过度的。</p>
<p>一个示例:</p>
<pre class="listing"><span class="Comment"># 这是一个如何在Nim中建模抽象语法树的示例</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># the different node types</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># a leaf with an integer value</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># a leaf with a float value</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># a leaf with a string value</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># an addition</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># a subtraction</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># an if statement</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># ``kind`` 字段是鉴别字段</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">1.0</span><span class="Punctuation">)</span>
<span class="Comment"># 以下语句引发了一个`FieldError`异常，因为 n.kind的值不匹配：</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span></pre><p>从该示例可以看出，对象层次结构的优点是不需要在不同对象类型之间进行转换。但是，访问无效对象字段会引发异常。</p>

<h2><a class="toc-backref" id="面向对象编程-方法调用语法" href="#面向对象编程-方法调用语法">方法调用语法</a></h2><p>调用例程有一个语法糖：语法 <tt class="docutils literal"><span class="pre">obj.method（args）</span></tt> 可以用来代替 <tt class="docutils literal"><span class="pre">method（obj，args）</span></tt> 。如果没有剩余的参数，则可以省略括号： <tt class="docutils literal"><span class="pre">obj.len</span></tt> （而不是 <tt class="docutils literal"><span class="pre">len（obj）</span></tt> ）。</p>
<p>此方法调用语法不限于对象，它可以用于任何类型：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Comment"># is the same as echo len(&quot;abc&quot;)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># the same as writeLine(stdout, &quot;Hallo&quot;)</span></pre><p>（查看方法调用语法的另一种方法是它提供了缺少的后缀表示法。）</p>
<p>所以“纯面向对象”代码很容易编写：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span>

<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;Give a list of numbers (separated by spaces): &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Operator">.</span><span class="Identifier">readLine</span><span class="Operator">.</span><span class="Identifier">splitWhitespace</span><span class="Operator">.</span><span class="Identifier">map</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">max</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot; is the maximum!&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="面向对象编程-属性" href="#面向对象编程-属性">属性</a></h2><p>如上例所示，Nim不需要 <em>get-properties</em> ：使用 <em>方法调用语法</em> 调用的普通get-procedures实现相同。但设定值是不同的；为此需要一个特殊的setter语法：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">h</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 由于缺少星号，无法从模块外部访问</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## setter of host address</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">h</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## getter of host address</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">h</span>

<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">new</span> <span class="Identifier">s</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># same as `host=`(s, 34)</span></pre><p>（该示例还显示了 <tt class="docutils literal"><span class="pre">inline</span></tt> 程序。）</p>
<p>可以重载 <tt class="docutils literal"><span class="pre">[]</span></tt> 数组访问运算符来提供 <span id="数组属性_1">数组属性</span> ：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Vector</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># setter</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Comment"># getter</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span></pre><p>这个例子很愚蠢，因为矢量更好地由一个已经提供 <tt class="docutils literal"><span class="pre">v []</span></tt> 访问的元组建模。</p>

<h2><a class="toc-backref" id="面向对象编程-动态分发" href="#面向对象编程-动态分发">动态分发</a></h2><p>程序总是使用静态调度。对于动态调度，用 <tt class="docutils literal"><span class="pre">method</span></tt> 替换 <tt class="docutils literal"><span class="pre">proc</span></tt> 关键字：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Expression</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## abstract base class for an expression</span>
  <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span>

<span class="Comment"># 注意：'eval'依赖于动态绑定</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 重写基方法</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Identifier">Literal</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>请注意，在示例中，构造函数 <tt class="docutils literal"><span class="pre">newLit</span></tt> 和 <tt class="docutils literal"><span class="pre">newPlus</span></tt> 是procs，因为它们使用静态绑定更有意义，但 <tt class="docutils literal"><span class="pre">eval</span></tt> 是一种方法，因为它需要动态绑定。</p>
<p><strong>注意：</strong> 从Nim 0.20开始，要使用多方法，必须在编译时明确传递 <tt class="docutils literal"><span class="pre">--multimethods：on</span></tt> 。</p>
<p>在多方法中，具有对象类型的所有参数都用于分发：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;2&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span>
<span class="Identifier">new</span> <span class="Identifier">a</span>
<span class="Identifier">new</span> <span class="Identifier">b</span>
<span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Comment"># output: 2</span></pre><p>如示例所示，多方法的调用不能模糊：碰撞2比碰撞1更受欢迎，因为分辨率从左到右工作。因此 <tt class="docutils literal"><span class="pre">Unit，Thing</span></tt> 比 <tt class="docutils literal"><span class="pre">Thing，Unit</span></tt> 更受欢迎。</p>
<p><strong>性能说明</strong>: Nim不会生成虚方法表，但会生成调度树。这避免了方法调用的昂贵间接分支并启用内联。但是，其他优化（如编译时评估或死代码消除）不适用于方法。</p>

<h1><a class="toc-backref" id="异常" href="#异常">异常</a></h1><p>在Nim中，异常是对象。按照惯例，异常类型后缀为“Error”。 <a class="reference external" href="system.html">system</a> 模块定义了一个您可能想要坚持的异常层次结构。异常来自 <tt class="docutils literal"><span class="pre">system.Exception</span></tt> ，它提供了通用接口。</p>
<p>必须在堆上分配异常，因为它们的生命周期是未知的。编译器将阻止您引发在堆栈上创建的异常。所有引发的异常应该至少指定在 <tt class="docutils literal"><span class="pre">msg</span></tt> 字段中引发的原因。</p>
<p>一个约定是在异常情况下应该引发异常：例如，如果无法打开文件，则不应引发异常，因为这很常见（文件可能不存在）。</p>

<h2><a class="toc-backref" id="异常-raise语句" href="#异常-raise语句">Raise语句</a></h2><p>发起一个异常用 <tt class="docutils literal"><span class="pre">raise</span></tt> 语句：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">OSError</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
<span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">e</span></pre><p>如果 <tt class="docutils literal"><span class="pre">raise</span></tt> 关键字后面没有表达式，则最后一个异常是 <em>re-raised</em> 。为了避免重复这种常见的代码模式，可以使用 <tt class="docutils literal"><span class="pre">system</span></tt> 模块中的模板 <tt class="docutils literal"><span class="pre">newException</span></tt> ：</p>
<pre class="listing"><span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="异常-try语句" href="#异常-try语句">Try语句</a></h2><p><tt class="docutils literal"><span class="pre">try</span></tt> 语句处理异常：</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>

<span class="Comment"># 读取应包含数字的文本文件的前两行并尝试添加</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;sum: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;overflow!&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;could not convert string to integer&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;IO error!&quot;</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Unknown exception!&quot;</span>
    <span class="Comment"># reraise the unknown exception:</span>
    <span class="Keyword">raise</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p>除非引发异常，否则执行 <tt class="docutils literal"><span class="pre">try</span></tt> 之后的语句。然后执行适当的 <tt class="docutils literal"><span class="pre">except</span></tt> 部分。</p>
<p>如果存在未明确列出的异常，则执行空的 <tt class="docutils literal"><span class="pre">except</span></tt> 部分。它类似于 <tt class="docutils literal"><span class="pre">if</span></tt> 语句中的 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。</p>
<p>如果有一个 <tt class="docutils literal"><span class="pre">finally</span></tt> 部分，它总是在异常处理程序之后执行。</p>
<p>在 <tt class="docutils literal"><span class="pre">except</span></tt> 部分中 <em>消耗</em> 异常。如果未处理异常，则通过调用堆栈传播该异常。这意味着程序的其余部分 - 不在 <tt class="docutils literal"><span class="pre">finally</span></tt> 子句中 - 通常不会被执行（如果发生异常）。</p>
<dl class="docutils"><dt>如果你需要*访问 <tt class="docutils literal"><span class="pre">except</span></tt> 分支中的实际异常对象或消息，你可以使用来自 <a class="reference external" href="system.html">system</a> 模块的 <a class="reference external" href="system.html#getCurrentException">getCurrentException()</a> 和</dt>
<dd><a class="reference external" href="system.html#getCurrentExceptionMsg">getCurrentExceptionMsg()</a> 的过程。例：</dd>
<dt>.. code-block:: nim</dt>
<dd><dl class="docutils"><dt>try:</dt>
<dd>doSomethingHere()</dd>
<dt>except:</dt>
<dd><dl class="docutils"><dt>let</dt>
<dd>e = getCurrentException() msg = getCurrentExceptionMsg()</dd>
</dl>
<p>echo &quot;Got exception &quot;, repr(e), &quot; with message &quot;, msg</p>
</dd>
</dl>
</dd>
</dl>

<h2><a class="toc-backref" id="异常-引发异常的procs注释" href="#异常-引发异常的procs注释">引发异常的procs注释</a></h2><p>通过使用可选的 <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> pragma，你可以指定proc是为了引发一组特定的异常，或者根本没有异常。如果使用 <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> pragma，编译器将验证这是否为真。例如，如果指定proc引发 <tt class="docutils literal"><span class="pre">IOError</span></tt> ，并且在某些时候它（或它调用的一个proc）开始引发一个新的异常，编译器将阻止该proc进行编译。用法示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">complexProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">ArithmeticError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">simpleProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span></pre><p>一旦你有这样的代码，如果引发的异常列表发生了变化，编译器就会停止，并指出proc停止验证pragma的行并且没有捕获引发的异常，以及文件和行所在的行。 正在引发未捕获的异常，这可能有助于您找到已更改的有问题的代码。</p>
<p>如果你想将 <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> pragma添加到现有代码中，编译器也可以帮助你。你可以在你的proc中添加 <tt class="docutils literal"><span class="pre">{.effects.}</span></tt> pragma语句， 编译器将输出所有推断的效果直到那一点（异常跟踪是Nim效果系统的一部分）。 查找proc引发的异常列表的另一种更迂回的方法是使用Nim <tt class="docutils literal"><span class="pre">doc2</span></tt> 命令，该命令为整个模块生成文档，并使用引发的异常列表来装饰所有过程。 您可以在手册中阅读有关Nim的 <a class="reference external" href="manual.html＃effect-system">效果系统和相关编译指示的更多信息</a> 。</p>

<h1><a class="toc-backref" id="泛型" href="#泛型">泛型</a></h1><p>泛型是Nim用 <span id="类型化参数_1">类型化参数</span> 参数化procs，iterators或类型的方法。它们对于高效型安全容器最有用：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">BinaryTree</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Comment"># 二叉树是左右子树用泛型参数 ``T`` 可能nil的泛型</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                   <span class="Comment"># the data stored in a node</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># 节点构造</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">data</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># insert a node into the tree</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Comment"># 比较数据; 使用对任何有 ``==`` and ``&lt;`` 操作符的类型有用的泛型 ``cmp`` 过程</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 方便过程:</span>
  <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">preorder</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># 二叉树前序遍历。</span>
  <span class="Comment"># 因为递归迭代器没有实现，用显式的堆栈(更高效):</span>
  <span class="Keyword">var</span> <span class="Identifier">stack</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">while</span> <span class="Identifier">n</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
      <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">stack</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>  <span class="Comment"># 右子树push到堆栈</span>
      <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">le</span>          <span class="Comment"># 跟随左指针</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># 用 ``string`` 实例化一个二叉树</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># 实例化 ``newNode`` 和 ``add``</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># 实例化第二个 ``add`` 过程</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">preorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">)</span></pre><p>该示例显示了通用二叉树。根据上下文，括号用于引入类型参数或实例化通用proc，迭代器或类型。如示例所示，泛型使用重载：使用“add”的最佳匹配。 序列的内置 <tt class="docutils literal"><span class="pre">add</span></tt> 过程不是隐藏的，而是在 <tt class="docutils literal"><span class="pre">preorder</span></tt> 迭代器中使用。</p>

<h1><a class="toc-backref" id="模板" href="#模板">模板</a></h1><p>模板是一种简单的替换机制，可以在Nim的抽象语法树上运行。模板在编译器的语义传递中处理。它们与语言的其余部分很好地集成，并且不会共享C的预处理器宏缺陷。</p>
<p>要 <em>调用</em> 模板，将其作为过程。</p>
<p>Example:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># 此定义存在于system模块中</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># 编译器将其重写为：assert（not（5 == 6））</span></pre><p>The <tt class="docutils literal"><span class="pre">!=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt> operators are in fact templates: this has the benefit that if you overload the <tt class="docutils literal"><span class="pre">==</span></tt> operator, the <tt class="docutils literal"><span class="pre">!=</span></tt> operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</p>
<p><tt class="docutils literal"><span class="pre">a &gt; b</span></tt> 变换成 <tt class="docutils literal"><span class="pre">b &lt; a</span></tt>. <tt class="docutils literal"><span class="pre">a in b</span></tt> 变换成 <tt class="docutils literal"><span class="pre">contains(b, a)</span></tt>. <tt class="docutils literal"><span class="pre">notin</span></tt> 和 <tt class="docutils literal"><span class="pre">isnot</span></tt> 顾名思义。</p>
<p>模板对于延迟计算特别有用。考虑一个简单的日志记录过程：</p>
<pre class="listing"><span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Keyword">proc</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>这段代码有一个缺点：如果 <tt class="docutils literal"><span class="pre">debug</span></tt> 有一天设置为false，那么仍然会执行相当昂贵的 <tt class="docutils literal"><span class="pre">$</span></tt> 和 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 操作！ （程序的参数求值是 <em>急切</em> ）。</p>
<p>将 <tt class="docutils literal"><span class="pre">log</span></tt> proc转换为模板解决了这个问题：</p>
<pre class="listing"><span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Keyword">template</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>参数的类型可以是普通类型，也可以是元类型 <tt class="docutils literal"><span class="pre">untyped</span></tt> ， <tt class="docutils literal"><span class="pre">typed</span></tt> 或 <tt class="docutils literal"><span class="pre">type</span></tt> 。 <tt class="docutils literal"><span class="pre">type</span></tt> 表示只有一个类型符号可以作为参数给出， <tt class="docutils literal"><span class="pre">untyped</span></tt> 表示符号查找，并且在表达式传递给模板之前不执行类型解析。</p>
<p>如果模板没有显式返回类型，则使用 <tt class="docutils literal"><span class="pre">void</span></tt> 与proc和方法保持一致。</p>
<p>要将一个语句块传递给模板，请使用 <tt class="docutils literal"><span class="pre">untyped</span></tt> 作为最后一个参数：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">filename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">FileMode</span><span class="Punctuation">,</span>
                  <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">fn</span> <span class="Operator">=</span> <span class="Identifier">filename</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>在示例中，两个 <tt class="docutils literal"><span class="pre">writeLine</span></tt> 语句绑定到 <tt class="docutils literal"><span class="pre">body</span></tt> 参数。 <tt class="docutils literal"><span class="pre">withFile</span></tt> 模板包含样板代码，有助于避免常见错误：忘记关闭文件。 注意 <tt class="docutils literal"><span class="pre">let fn = filename</span></tt> 语句如何确保 <tt class="docutils literal"><span class="pre">filename</span></tt> 只被求值一次。</p>

<h2><a class="toc-backref" id="模板-示例colon-提升过程" href="#模板-示例colon-提升过程">示例: 提升过程</a></h2><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">math</span>

<span class="Keyword">template</span> <span class="Identifier">liftScalarProc</span><span class="Punctuation">(</span><span class="Identifier">fname</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment">## 使用一个标量参数提升一个proc并返回一个</span>
  <span class="Comment">## 标量值（例如 ``proc sssss[T](x: T): float``）,</span>
  <span class="Comment">## 来提供模板过程可以处理单个seq[T]形参或嵌套seq[seq[]]或同样的类型</span>
  <span class="Comment">##</span>
  <span class="Comment">## .. code-block:: Nim</span>
  <span class="Comment">##  liftScalarProc(abs)</span>
  <span class="Comment">##  # 现在 abs(@[@[1,-2], @[-2,-3]]) == @[@[1,2], @[2,3]]</span>
  <span class="Keyword">proc</span> <span class="Identifier">fname</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">openarray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">auto</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">temp</span><span class="Punctuation">:</span> <span class="Identifier">T</span>
    <span class="Keyword">type</span> <span class="Identifier">outType</span> <span class="Operator">=</span> <span class="Keyword">type</span><span class="Punctuation">(</span><span class="Identifier">fname</span><span class="Punctuation">(</span><span class="Identifier">temp</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">outType</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">fname</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">liftScalarProc</span><span class="Punctuation">(</span><span class="Identifier">sqrt</span><span class="Punctuation">)</span>   <span class="Comment"># 让sqrt()可以用于序列</span>
<span class="Identifier">echo</span> <span class="Identifier">sqrt</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="FloatNumber">4.0</span><span class="Punctuation">,</span> <span class="FloatNumber">16.0</span><span class="Punctuation">,</span> <span class="FloatNumber">25.0</span><span class="Punctuation">,</span> <span class="FloatNumber">36.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>   <span class="Comment"># =&gt; @[2.0, 4.0, 5.0, 6.0]</span></pre>
<h1><a class="toc-backref" id="编译成javascript" href="#编译成javascript">编译成Javascript</a></h1><p>Nim代码可以编译成JavaScript。为了写JavaScript兼容的代码你要记住以下几个方面：</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">addr</span></tt> 和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 在JavaScript中有略微不同的语义。你不确定它们是怎样编译成JavaScript，建议避免使用。</li>
<li>在JavaScript中的 <tt class="docutils literal"><span class="pre">cast[T](x)</span></tt> 被转换为 <tt class="docutils literal"><span class="pre">(x)</span></tt> ，除了在有符号/无符号整数之间进行转换，在这种情况下，它在C语言中表现为静态强制转换。</li>
<li><tt class="docutils literal"><span class="pre">cstring</span></tt> 在JavaScript中表示JavaScript字符串。 只有在语义上合适时才使用 <tt class="docutils literal"><span class="pre">cstring</span></tt> 是一个好习惯。例如。不要使用 <tt class="docutils literal"><span class="pre">cstring</span></tt> 作为二进制数据缓冲区。</li>
</ul>

<h1><a class="toc-backref" id="part-3" href="#part-3">Part 3</a></h1><p>下一部分将是完全关于使用宏的元编程： <a class="reference external" href="tut3.html">Part III</a> </p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2019-08-09 11:46:33 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
